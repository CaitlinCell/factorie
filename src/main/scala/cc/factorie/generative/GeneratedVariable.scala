/* Copyright (C) 2008-2010 University of Massachusetts Amherst,
   Department of Computer Science.
   This file is part of "FACTORIE" (Factor graphs, Imperative, Extensible)
   http://factorie.cs.umass.edu, http://code.google.com/p/factorie/
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License. */

package cc.factorie.generative
import cc.factorie._
import cc.factorie.la._
import cc.factorie.util.Substitutions
import scala.collection.mutable.{HashSet,ArrayBuffer}

/** A variable that keeps track of some of its neighboring factors.
    We can't be guaranteed that it will return all factors; to be sure ask the Model.factors(Variable). */
trait VarWithFactors extends Variable {
  def factors: Seq[Factor]
}

// A collection of abstract Variables (and a generic Family) for generative models (directed Bayesian networks, 
// as opposed to undirected in which there is not a DAG-shaped generative storyline).

/** A variable whose value has been generated by a probability distribution parameterized by some parent variables.
    May or may not be mutable. */
trait GeneratedVar extends VarWithFactors {
  //type VariableType <: GeneratedVar
  // TODO Don't make this "var".  The ~ method should be the only place that this gets changed!
  var parentFactor: GenerativeFactor = null
  def factors: Seq[GenerativeFactor] = List(parentFactor)
  def sampledValue: Value = {
    parentFactor.sampledValue.asInstanceOf[Value]
  }
  def pr = parentFactor.pr
  def logpr = parentFactor.logpr
  /*def ~(f:GenerativeFamily#Factor): this.type = {
    assert(f.family.isInstanceOf[GenerativeFamily])
    //assert(f._1 eq this) // TODO How to check this?
    parentFactor = f
    this
  }*/
  // TODO The type parameter below doesn't actually enforce what we want.  Fix this.
  def ~[V<:this.VariableType with GeneratedVar](partialFactor:Function1[V,GenerativeFactor]): this.type = {
    assert(parentFactor eq null)
    parentFactor = partialFactor(this.asInstanceOf[V])
    for (p <- parentFactor.parents) p.asInstanceOf[Parameter].addChild(this) // TODO Think about this more.
    this
  }

  /** The list of random variables on which the generation of this variable's value depends. 
      By convention the first variable of the parentFactor is the child, 
      and the remainder are its parents. */
  def parents: Seq[Parameter] = parentFactor.parents.asInstanceOf[Seq[Parameter]]
  /** The list of random variables on which the generation of this variable's value depends,
      either directly or via a sequence of deterministic variables.  Changes to these variables
      cause the value of this.pr to change. */
  def extendedParents: Seq[Parameter] = {
    val result = new scala.collection.mutable.ArrayBuffer[Parameter]
    result ++= parents
    for (parent <- parents) parent match {
      case gv:GeneratedVar if (gv.isDeterministic) => result ++= gv.extendedParents
      case _ => {}
    }
    result
  }
  /** Returns true if the value of this parameter is a deterministic (non-stochastic) function of its parents. */
  def isDeterministic = false
}


/** A GeneratedVar that is mutable and whose value may be changed by sampling. */
trait MutableGeneratedVar extends GeneratedVar with MutableVar {
  /** Sample a new value for this variable given only its parents. */
  def sampleFromParents(implicit d:DiffList = null): this.type = {
    set(this.sampledValue)(d)
    this
  }
  def :~[V<:this.VariableType](partialFactor:Function1[V,GenerativeFactor]): this.type = {
    this ~ partialFactor
    this.set(this.sampledValue)(null)
    this
  }
}

// Consider something like this, but then the Vars container has a parent and children, and so do the contents?
//trait GeneratedVars[V<:GeneratedVar] extends Vars[V] with GeneratedVar

// TODO Are these still necessary?  Consider deleting.  Yes!
trait RealGenerating {
  def sampleDouble: Double
  def pr(x:Double): Double
  def logpr(x:Double): Double
}
trait DiscreteGenerating {
  def length: Int
  def sampleInt: Int
  def pr(index:Int): Double
  def logpr(index:Int): Double
}
trait ProportionGenerating {
  def sampleProportions: Proportions
  def pr(p:Proportions): Double
  def logpr(p:Proportions): Double
}



// Generative Factors

trait GenerativeFactor extends Factor {
  type ChildType <: GeneratedVar
  type StatisticsType <: Statistics
  def statistics: StatisticsType
  def child: ChildType
  def parents: Seq[GeneratedVar]
  def pr(s:StatisticsType): Double
  def pr: Double = pr(statistics)
  def logpr(s:StatisticsType): Double = math.log(pr(s))
  def logpr: Double = logpr(statistics)
  def sampledValue(s:StatisticsType): Any
  def sampledValue: Any = sampledValue(statistics)
  // TODO Consider removing these methods because we'd have specialized code in the inference recipes.
  /** Update sufficient statistics in collapsed parents, using current value of child, with weight.  Return false on failure. */
  // TODO Consider passing a second argument which is the value of the child to use in the update
  def updateCollapsedParents(weight:Double): Boolean = throw new Error(factorName+": Collapsing parent not implemented.")
  def updateCollapsedChild(): Boolean = throw new Error(factorName+": Collapsing child not implemented.")
  def resetCollapsedChild(): Boolean = throw new Error(factorName+": Resetting child not implemented.")
}

trait GenerativeFactorWithStatistics1[C<:GeneratedVar] extends GenerativeFactor with FactorWithStatistics1[C] {
  type ChildType = C
  def child = _1
  def parents = Nil
  def score(s:Statistics) = logpr(s.asInstanceOf[StatisticsType]) // Can't define score earlier because inner class Factor.Statistics not defined until here
}

trait GenerativeFactorWithStatistics2[C<:GeneratedVar,P1<:Parameter] extends GenerativeFactor with FactorWithStatistics2[C,P1] {
  type ChildType = C
  def child = _1
  def parents = Seq(_2)
  // TODO Consider this:
  //def parents = _2 match { case vars:Vars[Parameter] => vars; case _ => Seq(_2) }
  def score(s:Statistics) = logpr(s.asInstanceOf[StatisticsType])
}

trait GenerativeFactorWithStatistics3[C<:GeneratedVar,P1<:Parameter,P2<:Parameter] extends GenerativeFactor with FactorWithStatistics3[C,P1,P2] {
  type ChildType = C
  def child = _1
  def parents = Seq(_2, _3)
  def score(s:Statistics) = logpr(s.asInstanceOf[StatisticsType])
}

trait GenerativeFactorWithStatistics4[C<:GeneratedVar,P1<:Parameter,P2<:Parameter,P3<:Parameter] extends GenerativeFactor with FactorWithStatistics4[C,P1,P2,P3] {
  type ChildType = C
  def child = _1
  def parents = Seq(_2, _3, _4)
  def score(s:Statistics) = logpr(s.asInstanceOf[StatisticsType])
}

trait GenerativeFamily2[Child<:GeneratedVar,Parent1<:Parameter] {
  type C = Child
  type P1 = Parent1
  trait Factor extends GenerativeFactorWithStatistics2[C,P1] 
  def newFactor(c:C, p1:P1): Factor
  def apply(p1:P1) = new Function1[C,Factor] {
    def apply(c:C) = newFactor(c, p1)
  }
}

trait GenerativeFamily3[Child<:GeneratedVar,Parent1<:Parameter,Parent2<:Parameter] {
  type C = Child
  type P1 = Parent1
  type P2 = Parent2
  trait Factor extends GenerativeFactorWithStatistics3[C,P1,P2] 
  def newFactor(c:C, p1:P1, p2:P2): Factor
  def apply(p1:P1,p2:P2) = new Function1[C,Factor] {
    def apply(c:C) = newFactor(c, p1, p2)
  }
}

trait GenerativeFamily4[Child<:GeneratedVar,Parent1<:Parameter,Parent2<:Parameter,Parent3<:Parameter] {
  type C = Child
  type P1 = Parent1
  type P2 = Parent2
  type P3 = Parent3
  trait Factor extends GenerativeFactorWithStatistics4[C,P1,P2,P3] 
  def newFactor(c:C, p1:P1, p2:P2, p3:P3): Factor
  def apply(p1:P1,p2:P2,p3:P3) = new Function1[C,Factor] {
    def apply(c:C) = newFactor(c, p1, p2, p3)
  }
}

