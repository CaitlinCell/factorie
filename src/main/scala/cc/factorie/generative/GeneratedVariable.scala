/* Copyright (C) 2008-2010 University of Massachusetts Amherst,
   Department of Computer Science.
   This file is part of "FACTORIE" (Factor graphs, Imperative, Extensible)
   http://factorie.cs.umass.edu, http://code.google.com/p/factorie/
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at
    http://www.apache.org/licenses/LICENSE-2.0
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License. */

package cc.factorie.generative
import cc.factorie._
import cc.factorie.la._
import cc.factorie.util.Substitutions
import scala.collection.mutable.{HashSet,ArrayBuffer}

/** A variable that keeps track of some of its neighboring factors.
    We can't be guaranteed that it will return all factors; to be sure ask the Model.factors(Variable). */
trait VarWithFactors extends Variable {
  def factors: Seq[Factor]
}

// A collection of abstract Variables (and a generic Family) for generative models (directed Bayesian networks, 
// as opposed to undirected in which there is not a DAG-shaped generative storyline).

/** A variable whose value has been generated by a probability distribution parameterized by some parent variables.
    May or may not be mutable. */
trait GeneratedVar extends VarWithFactors {
  //type VariableType <: GeneratedVar
  var parentFactor: GenerativeFamily#Factor = null
  def factors: Seq[GenerativeFamily#Factor] = List(parentFactor)
  def sampledValue: Value = {
    val generativeTemplate = parentFactor.family
    //println("GeneratedVar.sampledValue generativeFamily "+generativeTemplate.getClass)
    generativeTemplate.sampledValue(parentFactor.statistics.asInstanceOf[generativeTemplate.StatisticsType]).asInstanceOf[Value]
  }
  // TODO Consider template.pr(parentFactor) for efficiency
  def pr = parentFactor.family.pr(parentFactor.statistics)
  def logpr = parentFactor.family.logpr(parentFactor.statistics)
  /*def ~(f:GenerativeFamily#Factor): this.type = {
    assert(f.family.isInstanceOf[GenerativeFamily])
    //assert(f._1 eq this) // TODO How to check this?
    parentFactor = f
    this
  }*/
  // TODO The type parameter below doesn't actually enforce what we want.  Fix this.
  def ~[V<:this.VariableType with GeneratedVar](partialFactor:Function1[V,GenerativeFamily#Factor]): this.type = {
    assert(parentFactor eq null)
    parentFactor = partialFactor(this.asInstanceOf[V])
    for (p <- parentFactor.variables.tail) p.asInstanceOf[Parameter].addChild(this) // TODO Think about this more.
    this
  }

  /** The list of random variables on which the generation of this variable's value depends. 
      By convention the first variable of the parentFactor is the child, 
      and the remainder are its parents. */
  def parents: Seq[Parameter] = parentFactor.variables.tail.asInstanceOf[Seq[Parameter]]
  /** The list of random variables on which the generation of this variable's value depends,
      either directly or via a sequence of deterministic variables.  Changes to these variables
      cause the value of this.pr to change. */
  def extendedParents: Seq[Parameter] = {
    val result = new scala.collection.mutable.ArrayBuffer[Parameter]
    result ++= parents
    for (parent <- parents) parent match {
      case gv:GeneratedVar if (gv.isDeterministic) => result ++= gv.extendedParents
      case _ => {}
    }
    result
  }
  /** Returns true if the value of this parameter is a deterministic (non-stochastic) function of its parents. */
  def isDeterministic = false
}


/** A GeneratedVar that is mutable and whose value may be changed by sampling. */
trait MutableGeneratedVar extends GeneratedVar with MutableVar {
  /** Sample a new value for this variable given only its parents. */
  def sampleFromParents(implicit d:DiffList = null): this.type = {
    set(this.sampledValue)(d)
    this
  }
  def :~[V<:this.VariableType](partialFactor:Function1[V,GenerativeFamily#Factor]): this.type = {
    this ~ partialFactor
    this.set(this.sampledValue)(null)
    this
  }
}


// TODO Are these still necessary?  Consider deleting
trait RealGenerating {
  def sampleDouble: Double
  def pr(x:Double): Double
  def logpr(x:Double): Double
}
trait DiscreteGenerating {
  def length: Int
  def sampleInt: Int
  def pr(index:Int): Double
  def logpr(index:Int): Double
}
trait ProportionGenerating {
  def sampleProportions: Proportions
  def pr(p:Proportions): Double
  def logpr(p:Proportions): Double
}



// Families

/*trait GenerativeFactor extends Factor {
  type StatisticsType <: cc.factorie.Statistics
  //type ChildType <: GenerativeVar
  override def template: GenerativeTemplate
  def sampledValue: Any
  def pr: Double
  def logpr: Double
  def child: GeneratedVar
  //def parents: Seq[Parameter]
  override def statistics: StatisticsType
  override def copy(s:Substitutions): GenerativeFactor
}*/

trait GenerativeFamily extends FamilyWithNeighborDomains {
  type ChildType <: GeneratedVar
  type FamilyType <: GenerativeFamily
  //matchNeighborDomains = false // There is just one Template for all variable classes, even with different domains.
  def child(f:FactorType): ChildType
  def pr(s:StatisticsType): Double
  def pr(s:cc.factorie.Statistics): Double = pr(s.asInstanceOf[StatisticsType])
  def logpr(s:StatisticsType) = math.log(pr(s))
  def logpr(s:cc.factorie.Statistics): Double = logpr(s.asInstanceOf[StatisticsType])
  def score(s:StatisticsType) = logpr(s)
  def sampledValue(s:StatisticsType): ChildType#Value
  def sampledValue(s:cc.factorie.Statistics): ChildType#Value = sampledValue(s.asInstanceOf[StatisticsType])
  /** Update sufficient statistics in collapsed parents, using current value of child, with weight.  Return false on failure. */
  def updateCollapsedParents(f:FactorType, weight:Double): Boolean = throw new Error(f.family.getClass.toString+": Collapsing parent not implemented.")
  def updateCollapsedParents(f:cc.factorie.Factor, weight:Double): Boolean = updateCollapsedParents(f.asInstanceOf[FactorType], weight)
  // TODO Put functionality of updateCollapsedChild into resetCollapsedChild (it resets and initializes to distribution of parent)
  def updateCollapsedChild(f:FactorType): Boolean = throw new Error(f.family.getClass.toString+": Collapsing child not implemented.")
  def updateCollapsedChild(f:cc.factorie.Factor): Boolean = updateCollapsedChild(f.asInstanceOf[FactorType])
  def resetCollapsedChild(f:FactorType): Boolean = throw new Error(f.family.getClass.toString+": Resetting child not implemented.")
  def resetCollapsedChild(f:cc.factorie.Factor): Boolean = resetCollapsedChild(f.asInstanceOf[FactorType])
  /*trait Factor extends super.Factor {
    def child: ChildType = GenerativeFamily.this.child(this.asInstanceOf[FactorType])
    def updateCollapsedParents(weight:Double): Boolean = GenerativeFamily.this.updateCollapsedParents(this.asInstanceOf[FactorType], weight)
  }*/
}

trait GenerativeFamilyWithStatistics1[C<:GeneratedVar] extends FamilyWithStatistics1[C] with GenerativeFamily {
  thisTemplate =>
  //type FamilyType <: GenerativeFamilyWithStatistics1[C]
  type ChildType = C
  def child(f:Factor): C = f._1
  def apply(): Function1[C,Factor] = new Function1[C,Factor] {
    def apply(c:C) = Factor(c)
  }
  /*override def factors(v:Variable): Seq[FactorType] = v match {
    case gv:GeneratedVar => gv.parentFactor match { case pf:Factor => if (pf.family eq thisTemplate) List(pf) else Nil; case _ => Nil }
    case _ => Nil
  }*/
}

trait GenerativeFamilyWithStatistics2[C<:GeneratedVar,P1<:Parameter] extends FamilyWithStatistics2[C,P1] with GenerativeFamily {
  thisTemplate =>
  type ChildType = C
  //type FamilyType <: GenerativeFamilyWithStatistics2[C,P1]
  def child(f:Factor): C = f._1
  def apply(p1:P1) = new Function1[C,Factor] {
    def apply(c:C) = Factor(c, p1)
  }
  //def unroll1(c:C) = if (c.parentFactor.family eq thisTemplate) List(c.parentFactor.asInstanceOf[Factor]) else Nil
  //def unroll2(p1:P1) = p1.childFactors.filter(_.family eq thisTemplate).asInstanceOf[Seq[Factor]]
}

trait GenerativeFamilyWithStatistics3[C<:GeneratedVar,P1<:Parameter,P2<:Parameter] extends FamilyWithStatistics3[C,P1,P2] with GenerativeFamily {
  thisTemplate =>
  type ChildType = C
  def child(f:Factor): C = f._1
  def apply(p1:P1,p2:P2) = new Function1[C,Factor] {
    def apply(c:C) = Factor(c, p1, p2)
  }
  //def unroll1(c:C) = if (c.parentFactor.family eq thisTemplate) List(c.parentFactor.asInstanceOf[Factor]) else Nil
  //def unroll2(p1:P1) = p1.childFactors.filter(_.family eq thisTemplate).asInstanceOf[Seq[Factor]]
  //def unroll3(p2:P2) = p2.childFactors.filter(_.family eq thisTemplate).asInstanceOf[Seq[Factor]]
}

trait GenerativeFamilyWithStatistics4[C<:GeneratedVar,P1<:Parameter,P2<:Parameter,P3<:Parameter] extends FamilyWithStatistics4[C,P1,P2,P3] with GenerativeFamily {
  thisTemplate =>
  type ChildType = C
  def child(f:Factor): C = f._1
  def apply(p1:P1,p2:P2,p3:P3) = new Function1[C,Factor] { def apply(c:C) = Factor(c, p1, p2, p3) }
  //def unroll1(c:C) = if (c.parentFactor.family eq thisTemplate) List(c.parentFactor.asInstanceOf[Factor]) else Nil
  //def unroll2(p1:P1) = p1.childFactors.filter(_.family eq thisTemplate).asInstanceOf[Seq[Factor]]
  //def unroll3(p2:P2) = p2.childFactors.filter(_.family eq thisTemplate).asInstanceOf[Seq[Factor]]
  //def unroll4(p3:P3) = p3.childFactors.filter(_.family eq thisTemplate).asInstanceOf[Seq[Factor]]
}


