/* Copyright (C) 2008-2010 Univ of Massachusetts Amherst, Computer Science Dept
   This file is part of "FACTORIE" (Factor graphs, Imperative, Extensible)
   http://factorie.cs.umass.edu, http://code.google.com/p/factorie/
   This software is provided under the terms of the Eclipse Public License 1.0
   as published by http://www.opensource.org.  For further information,
   see the file `LICENSE.txt' included with this distribution. */

package cc.factorie.generative
import cc.factorie._
import cc.factorie.la._
import scala.collection.mutable.{HashSet,ArrayBuffer}

// A collection of abstract Variables (and a generic Template) for generative models (directed Bayesian networks, 
// as opposed to undirected in which there is not a DAG-shaped generative storyline).

/** A value that has been generated by a probability distribution parameterized by some parent variables.
    May or may not be mutable. */
trait GeneratedVar extends Variable {
  /** The list of random variables on which the generation of this variable's value depends. */
  def parents: Seq[Parameter]
  /** The list of random variables on which the generation of this variable's value depends,
      either directly or via a sequence of deterministic variables.  Changes to these variables
      cause the value of this.pr to change. */
  def extendedParents: Seq[Parameter] = {
    val result = new ArrayBuffer[Parameter]
    result ++= parents
    for (parent <- parents) parent match {
      case gv:GeneratedVar if (gv.isDeterministic) => result ++= gv.extendedParents
      case _ => {}
    }
    result
  }
  /** Parents, jumping over and selecting from "MixtureComponents" parents. */
  def generativeParents: Seq[Parameter] = {
    val p = parents
    this match {
      case self:MixtureOutcome => parents.map(_ match { case mc:MixtureComponents[_] => mc(self.choice.intValue); case p:Parameter => p })
      case _ => parents
    }
  }
  /** Sometimes pointers to parents are kept in a ParameterRef variable; 
      if so, return them here so that we can track diffs to them; 
      if not, return Nil or null entries in sequence with ordering matching 'parents'. */
  def parentRefs: Seq[AbstractParameterRef] = Nil
  /** The probability of the current value given its parents. */
  def pr:Double
  /** The log-probability of the current value given its parents. */
  def logpr:Double = math.log(pr)
  /** Returns true if the value of this parameter is a deterministic (non-stochastic) function of its parents. */
  def isDeterministic = false
}

/** A GeneratedVar that is mutable and whose value may be changed by sampling. */
trait GeneratedVariable extends GeneratedVar {
  /** Sample a new value for this variable given only its parents */
  def sample(implicit d:DiffList): Unit // TODO Consider renaming sampleFromParents to make clear that it doesn't account for children or others
  /** Sample a new value for this variable given only the specified parents, 
      ignoring its current registered parents. */
  def sampleFrom(parents:Seq[Variable])(implicit d:DiffList): Unit
}


trait RealGenerating {
  def sampleDouble: Double
  def pr(x:Double): Double
  def logpr(x:Double): Double
}
trait DiscreteGenerating {
  def length: Int
  def sampleInt: Int
  def pr(index:Int): Double
  def logpr(index:Int): Double
}
trait ProportionGenerating {
  def sampleProportions: Proportions
  def pr(p:Proportions): Double
  def logpr(p:Proportions): Double
}




/*class Binomial(p:RealVarParameter, trials:Int) extends OrdinalVariable with GeneratedVariable {
  this := 0
}*/
trait GeneratedDiscreteVar extends GeneratedVar with DiscreteVar {
  def proportions: Proportions
  def parents: Seq[Parameter] = List(proportions)
  def pr: Double = proportions(this.intValue)
  // override def setByIndex(i:Int)(implicit d:DiffList): Unit = proportions match { case m:DenseDirichletMultinomial => { m.increment(i, -1.0); super.setByIndex(i); m.increment(i, ,1.0) }; case _ => super.setByIndex(i) } // TODO This would be too slow, right?
  //def ~(proportions:Proportions): this.type = { proportions_=(proportions)(null); this }
}
trait GeneratedDiscreteVariable extends DiscreteVariable with GeneratedVariable with GeneratedDiscreteVar {
  def sample(implicit d:DiffList): Unit = set(proportions.sampleInt)
  def sampleFrom(parents:Seq[Variable])(implicit d:DiffList) = parents match {
    case Seq(p:Proportions) => set(p.sampleInt)
  }
  def maximize(implicit d:DiffList): Unit = set(proportions.maxPrIndex)
}
// A Discrete ~ Multinomial(Proportions), in which we can change the parent
class Discrete(p:Proportions, value:Int = 0) extends DiscreteVariable(value) with GeneratedDiscreteVariable {
  //assert(p.length <= domainSize)
  private val proportionsRef = new ParameterRef(p, this)
  def proportions = proportionsRef.value
  def proportions_=(p2:Proportions)(implicit d:DiffList = null) = { assert(p2.length <= domainSize); proportionsRef.set(p2) }
  override def parentRefs = List(proportionsRef)
}
trait GeneratedCategoricalVar[A] extends GeneratedDiscreteVar with CategoricalVar[A]
trait GeneratedCategoricalVariable[A] extends CategoricalVariable[A] with GeneratedDiscreteVariable with GeneratedCategoricalVar[A]
class Categorical[A](p:Proportions, value:A) extends CategoricalVariable(value) with GeneratedCategoricalVariable[A] {
  //assert(p.length <= domainSize)
  private val proportionsRef = new ParameterRef(p, this)
  def proportions = proportionsRef.value
  def proportions_=(p2:Proportions)(implicit d:DiffList) = { assert(p2.length <= domainSize); proportionsRef.set(p2) }
  override def parentRefs = List(proportionsRef)
}
class ObservedDiscrete(p:Proportions, value:Int) extends DiscreteObservation(value) with GeneratedVar {
  // TODO Rename "DiscreteConstant"?
  //assert(p.length <= domainSize)
  private val proportionsRef = new ParameterRef(p, this)
  def proportions = proportionsRef.value
  def proportions_=(p2:Proportions)(implicit d:DiffList) = { assert(p2.length <= domainSize); proportionsRef.set(p2) }
  def parents = List(proportionsRef.value)
  override def parentRefs = List(proportionsRef)
  def pr: Double = proportions(this.intValue)
}
class ObservedDiscretes(val proportions:Proportions, values:Traversable[Int] = Nil) extends DiscreteVars with GeneratedVar with ConstantValue {
  assert(proportions.length <= domainSize)
  proportions.addChild(this)(null)
  def parents = List(proportions)
  private val _values = values.toArray
  override def logpr: Double = { var result = 0.0; forIndex(_values.size)(index => result += math.log(proportions(index))); result }
  def pr: Double = math.exp(logpr)
  def vector: Vector = throw new Error
  def indices: Collection[Int] = throw new Error
}


// Templates
class GeneratedVarTemplate extends TemplateWithStatistics3[GeneratedVar,MixtureChoiceVariable,Vars[Parameter]] {
  protected def factorOfGeneratedVar(v:GeneratedVar) = v match {
    case v:MixtureOutcome => Factor(v, v.choice, Vars.fromSeq(v.parents))
    case _ => Factor(v, null, Vars.fromSeq(v.parents))
  }
  def unroll1(v:GeneratedVar) = factorOfGeneratedVar(v)
  def unroll2(c:MixtureChoiceVariable) = c.outcomes.map(v => Factor(v, c, Vars.fromSeq(v.parents)))
  def unroll3(vs:Vars[Parameter]) = throw new Error
  override def unroll3s(p:Parameter) = p match { 
    case m:MixtureComponents[Parameter] => m.children.map(factorOfGeneratedVar(_))
    case p:Parameter => p.children.flatMap(_ match {
      case m:MixtureComponents[Parameter] => m.childrenOf(p).map(factorOfGeneratedVar(_))
      case v:GeneratedVar => List(factorOfGeneratedVar(v))
    })
  }
  def score(s:Stat) = s._1.logpr // s.s1.logpr comes from GeneratedVariableTemplate; gateRefs similarly
  //def score(s:Stat) = { val mc = s.s1; mc.gateRefs.reduceLeft((sum,ref) => sum + mc.value.logpr(ref.outcome)) }
}
